/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.duke.group1.server;

import java.net.ServerSocket;
import java.net.Socket;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;

import edu.duke.group1.shared.*;


/**
 * Entrypoint for server
 */
public class App {

    /* this is the socket in server side */
    private ServerSocket serverSocket;

    /* this is used to contain all player-infos */
    private List<PlayerInfo> playerInfos;

    /* The server has many rooms, and one room has one game with many players */
    private List<Room> rooms;

    /**
     * Constructs an app object
     * initialize the rooms and playerinfos to an empty list
     */
    public App() throws IOException{
        this.playerInfos = new ArrayList<>();
        this.rooms = new ArrayList<>();
        this.playerInfos = Database.getPlayerInfos();
        this.rooms = Database.getRooms();
        for(PlayerInfo i : playerInfos){
            org.hibernate.Hibernate.initialize(i);
            i.setOnline(false);
        }
        for(Room i : rooms){
            org.hibernate.Hibernate.initialize(i);
            RoomController rc = new RoomController(i.getRoomId(), this);
            rc.start();
        }
    };

    /**
     * How many players now in total ?
     * @return the number of players
     */
    public int getPlayerInfoSize(){
        return playerInfos.size();
    }

    /**
     * find a player info
     * @param playerId the ID for the specific player
     * @return the player info has the playerId
     */
    public PlayerInfo getPlayerInfo(int playerId){
        for(PlayerInfo p : playerInfos){
            if(playerId == p.getPlayerId()){
                return p;
            }
        }
        return null;
    }

    /**
     * find a player info by account
     * @param account the account for the specific player
     * @return the player info has the account
     */
    public PlayerInfo getPlayerInfoByAccount(String account){
        for(PlayerInfo p : playerInfos){
            if(account.equals(p.getAccount())){
                return p;
            }
        }
        return null;
    }

    /**
     * find a room by ID
     *
     * @param roomId room ID
     * @return the room has the roomId
     */
    public Room getRoomById(int roomId){
        for(Room r : rooms){
            if(roomId == r.getRoomId()){
                return r;
            }
        }
        return null;
    }

    /**
     * a player create a room
     *
     * @param playerId the player to create room
     * @param playerNum the player number of the room created
     */
    public void createRoom(int playerId, int playerNum){
        int roomId = rooms.size();
        Room room = new Room(roomId, playerNum);
        rooms.add(room);
        room.addPlayerId(playerId);
        Database.addRoom(room);
        PlayerInfo p = getPlayerInfo(playerId);
        p.setCurrRoomId(roomId);
        RoomController rc = new RoomController(roomId, this);
        /* when the room is created, a room controller thread will be spawned to control the game flow */
        rc.start();
    }

    /**
     * a player join a room
     *
     * @param playerId the player to join room
     * @param roomId the room to join
     */
    public void joinRoom(int playerId, int roomId){
        PlayerInfo p = getPlayerInfo(playerId);
        p.setCurrRoomId(roomId);
        Room room = getRoomById(roomId);
        room.addPlayerId(playerId);
    }



    /**
     * Used to accept new listen and add it to player list
     * and assign it with a new action
     *      if playerNum == 0, means he / she is the host, need to choose
     *          how many players to play

     * @param playerNum ID for this player
     */
    public void addPlayerInfo(int playerNum){
        PlayerInfo playerInfo = new PlayerInfo(playerNum);
        if(playerNum == 0){//in evo1,it indicates it is the game host, it will be responsible for room creating
            playerInfo.setStatus("choosePlayerNum");
        }
        playerInfos.add(playerInfo);
    }

    /**
     * add a new player to the player list in v2
     * with its provided account and password
     *
     * @param account account for this player
     * @param password password for this player
     */
    public void addPlayerInfoV2(String account, String password){
        PlayerInfo playerInfo = new PlayerInfo(getPlayerInfoSize());
        playerInfo.setAccount(account);
        playerInfo.setPassword(password);
        Database.addPlayerInfo(playerInfo);
        playerInfos.add(playerInfo);
    }

    /**
     * Create a playerinfo
     * @param playerNum ID for this player
     */
    public PlayerInfo createPlayerInfo(int playerNum){
        PlayerInfo playerInfo = new PlayerInfo(playerNum);
        return playerInfo;
    }

    /**
     * save all available rooms for a player into the player info
     * the room's game should not be over
     * the room can either be waiting for players to join or it already has this player in game
     * @param playerInfo the player's info who want to join a room
     */
    public void setAvailableRooms(PlayerInfo playerInfo){
        Map<Integer, String> availableRooms = new HashMap<>();
        for(Room r : rooms){
            if(!r.isFull() ){
                String s = "Room " + r.getRoomId() + " map of " + r.getMap().getPlayerList().size() + " players, waiting for " + (r.getMap().getPlayerList().size() - r.getPlayerIds().size()) +" players";
                availableRooms.put(r.getRoomId(), s);
            }else if(r.getPlayerIds().contains(playerInfo.getPlayerId()) && !r.getStatus().equals("gameOver")){
                String s = "Room " + r.getRoomId() + " map of " + r.getMap().getPlayerList().size() + " players, now in " + r.getStatus() + " stage";
                availableRooms.put(r.getRoomId(), s);
            }
        }
        playerInfo.setAvailableRooms(availableRooms);
    }

    /**
     * continuing accepting player connections
     * assign and spawn a playerController for every player
     */
    public void acceptConnection() throws IOException{
        while (true) {
            Socket clientSocket = serverSocket.accept();
            PlayerController player = new PlayerController(clientSocket, this);
            player.start();
        }
    }

    /**
     * process actions sent from each player thread before the player login, and edit corresponding playerinfo
     * the player can either login or register
     *
     * @param action is the action sent from the client
     */
    public PlayerInfo processActionOutOfRoom(Action action){
        if(action instanceof RegisterAction){// the player wants to register
            String account = ((RegisterAction) action).getAccount();
            PlayerInfo playerInfo = createPlayerInfo(-1);
            playerInfo.setStatus("loginOrRegister");
            if(canRegister(account)){ //register succeed
                addPlayerInfoV2(account, ((RegisterAction) action).getPassword());
                playerInfo.setLoginMsg("Register succeed, please login.");
            }else{ //register failed
                playerInfo.setLoginMsg("Register failed, the name is already in use.");
            }
            return playerInfo;
        }else if(action instanceof LoginAction){//the player wants to login
            String account = ((LoginAction) action).getAccount();
            String password = ((LoginAction) action).getPassword();
            if(canLogin(account, password) && !getPlayerInfoByAccount(account).getOnline()){//login succeed, player will go to select room
                PlayerInfo playerInfo = getPlayerInfoByAccount(account);
                playerInfo.setOnline(true);
                playerInfo.setStatus("selectRoom");
                setAvailableRooms(playerInfo);
                Database.updatePlayerInfo(playerInfo);
                return playerInfo;
            }else{//login failed
                PlayerInfo playerInfo = createPlayerInfo(-1);
                playerInfo.setStatus("loginOrRegister");
                playerInfo.setLoginMsg("Login failed, wrong account or password");
                return playerInfo;
            }
        }else{

        }
        return null;
    }

    /**
     * process actions sent from each player thread, and edit corresponding playerinfo
     *
     * @param action is the action sent from the client
     * @param playerId is the action's sender
     */
    public void processAction(Action action, int playerId) throws InterruptedException {
        if(action instanceof ChoosePlayerNumAction){// the player sends a room creation action
            int playerNum = ((ChoosePlayerNumAction) action).getPlayerNum();
            createRoom(playerId, playerNum);
            PlayerInfo playerInfo = getPlayerInfo(playerId);//update playerinfo
            playerInfo.setMap(getRoomById(playerInfo.getCurrRoomId()).getMap());
            playerInfo.setNeedWait(true);
            playerInfo.setStatus("doPlacement");
            Database.updatePlayerInfo(playerInfo);
        }else if(action instanceof JoinRoomAction){// the player sends an join room action to get into the room he wants to enter
            int roomId = ((JoinRoomAction) action).getRoomId();

            if(getRoomById(roomId).isFull() && !getRoomById(roomId).getPlayerIds().contains(playerId)){//the room is already full, the player can not join it
                PlayerInfo playerInfo = getPlayerInfo(playerId);
                playerInfo.setLoginMsg("The room is already full, please select another room");
                setAvailableRooms(playerInfo);
                Database.updatePlayerInfo(playerInfo);
                return;
            }
            if(getRoomById(roomId).getPlayerIds().contains(playerId)){
                getPlayerInfo(playerId).setCurrRoomId(roomId);
            }else{
                joinRoom(playerId, roomId);
            }
            PlayerInfo playerInfo = getPlayerInfo(playerId);//update playerinfo
            playerInfo.setMap(getRoomById(playerInfo.getCurrRoomId()).getMap());
            Room room = getRoomById(roomId);
            if(room.getStatus().equals("ConnectPhase")){
                playerInfo.setNeedWait(true);
                playerInfo.setStatus("doPlacement");
                if(room.isFull()){
                    playerInfo.setNeedWait(false);
                    synchronized (room.getLock()) {
                        room.setStatus("doPlacement");
                        room.setPlayerMapping();
                        room.setUnplacedUnitsMapping();
                        room.getLock().notify();
                    }
                }
            }else if(room.getStatus().equals("doPlacement")){
                if(getRoomById(playerInfo.getCurrRoomId()).getMap().getUnplacedUnitsMapping(playerId) == 0){//the placement is finished, wait for other players
                    playerInfo.setNeedWait(true);
                    playerInfo.setStatus("doAttack");
                    if(isTurnFinished(room)){
                        playerInfo.setNeedWait(false);
                        synchronized (room.getLock()) {
                            room.setStatus("doAttack");
                            room.getLock().notify();
                        }
                    }
                }else{
                    playerInfo.setNeedWait(false);
                    playerInfo.setStatus("doPlacement");
                }
            }else{
                playerInfo.setNeedWait(false);
                playerInfo.setStatus("doAttack");
            }
            Database.updateRoom(room);
            Database.updatePlayerInfo(playerInfo);
        }else if(action instanceof Place){//the player sends a place action, it will be checked, if legal, perform it
            PlayerInfo playerInfo = getPlayerInfo(playerId);
            PlaceChecker p = new PlaceChecker();
            int UnplacedUnits = getRoomById(playerInfo.getCurrRoomId()).getMap().getUnplacedUnitsMapping(playerId);
            String s = p.checkPlaceRule(action, getRoomById(playerInfo.getCurrRoomId()).getMap(), UnplacedUnits);
            if(s == null){
                action.doAction(getRoomById(playerInfo.getCurrRoomId()).getMap());
                int newUnplacedUnits = UnplacedUnits - ((Place) action).getUnitNum();

                getRoomById(playerInfo.getCurrRoomId()).getMap().updateUnplacedUnitsMapping(playerId, newUnplacedUnits);
                playerInfo.setMap(getRoomById(playerInfo.getCurrRoomId()).getMap());
            }else{
                System.out.println(s);
            }
            if(getRoomById(playerInfo.getCurrRoomId()).getMap().getUnplacedUnitsMapping(playerId) == 0){//the placement is finished, wait for other players
                playerInfo.setNeedWait(true);
                playerInfo.setStatus("doAttack");
                Room room = getRoomById(playerInfo.getCurrRoomId());
                if(isTurnFinished(room)){
                    playerInfo.setNeedWait(false);
                    synchronized (room.getLock()) {
                        room.setStatus("doAttack");
                        room.getLock().notify();
                    }
                }
            }
            Database.updateRoom(getRoomById(playerInfo.getCurrRoomId()));
            Database.updatePlayerInfo(playerInfo);
        }else if(action instanceof Move){//the player sends a move action, add it to the room's move list
            PlayerInfo playerInfo = getPlayerInfo(playerId);
            Room room = getRoomById(playerInfo.getCurrRoomId());
            room.addToMoves((Move) action);
            Database.updateRoom(room);
        }else if(action instanceof Attack){//the player sends a attack action, add it to the room's attack list
            PlayerInfo playerInfo = getPlayerInfo(playerId);
            Room room = getRoomById(playerInfo.getCurrRoomId());
            room.addToAttacks((Attack) action);
            Database.updateRoom(room);
        }else if(action instanceof Finish){//the player sends a finish action, wait other players to finish
            PlayerInfo playerInfo = getPlayerInfo(playerId);
            playerInfo.setNeedWait(true);
            if(playerInfo.getStatus().equals("gameLose") || playerInfo.getStatus().equals("gameOver")){
                playerInfo.setNeedWait(false);
            }
            Room room = getRoomById(playerInfo.getCurrRoomId());
            if(isTurnFinished(room)){
                playerInfo.setNeedWait(false);
                synchronized (room.getLock()) {
                    executeOrders(playerInfo.getCurrRoomId());
                    room.getLock().notify();
                }
            }
            Database.updatePlayerInfo(playerInfo);
            Database.updateRoom(room);
        }else if(action instanceof UpgradeAction){//the player sends a upgrade action, add it to the room's upgrade list
            PlayerInfo playerInfo = getPlayerInfo(playerId);
            Room room = getRoomById(playerInfo.getCurrRoomId());
            room.addToUpgrades((UpgradeAction) action);
            Database.updateRoom(room);
        }else if(action instanceof UpgradeTechAction){//the player sends a upgrade action, add it to the room's upgrade list
            PlayerInfo playerInfo = getPlayerInfo(playerId);
            Room room = getRoomById(playerInfo.getCurrRoomId());
            room.addToUpgradeTechs((UpgradeTechAction) action);
            Database.updateRoom(room);
        }else if(action instanceof LoginAction){//the player wants to login
            String account = ((LoginAction) action).getAccount();
            //login succeed, player will go to select room
            PlayerInfo playerInfo = getPlayerInfoByAccount(account);
            playerInfo.setStatus("selectRoom");
            setAvailableRooms(playerInfo);
            Database.updatePlayerInfo(playerInfo);
        }
    }

    /**
     * execute all orders in a room
     * 1. all moves will be checked and performed
     * 2. all attacks will be checked and performed
     * 3. update every player's win/lose status
     * @param roomId is the room's id to execute order
     */
    public void executeOrders(int roomId) throws InterruptedException {
        Room room = getRoomById(roomId);
        AbstractMap map = room.getMap();
        List<Move> moves = room.getMoves();
        List<Attack> attacks = room.getAttacks();
        List<UpgradeAction> upgrades = room.getUpgrades();
        List<UpgradeTechAction> upgradetechs = room.getUpgradeTechs();
        MoveChecker mc = new MoveChecker();
        AttackChecker ac = new AttackChecker();
        UpgradeActionChecker uc = new UpgradeActionChecker();
        for(UpgradeAction i : upgrades){
            String s = uc.checkMyRule(i, map);
            if(s == null){
                i.doAction(map);
            }else {
                System.out.println(s);
            }
        }
        for(Move i : moves){//check and do all the moves
            String s = mc.checkMyRule(i, map);
            if(s == null){
                i.doAction(map);
            }else {
                System.out.println(s);
            }
        }
        for(Attack i : attacks){//check and do all the attacks
            String s = ac.checkMyRule(i, map);
            if(s == null){
                i.doAction(map);
            }else{
                System.out.println(s);
            }
        }
        map.solveAttacksAndSetRegionOwner(attacks);//perform all attacks on the map
        for(UpgradeTechAction i : upgradetechs){
            boolean success = i.upgradeTech(map);
            System.out.println("Upgrade success is " + success);
        }
        map.addOneUnit();//you can comment this line for quick game end when testing win or lose
        map.addOneResource();
        map.updatePlayerWinList();//update every player's winning status
        room.setMoves(new ArrayList<>());
        room.setAttacks(new ArrayList<>());
        room.setUpgrades(new ArrayList<>());
        room.setUpgradeTechs(new ArrayList<>());
        int count = 0;
        for(int i: room.getPlayerIds()){
            PlayerInfo p = getPlayerInfo(i);
            if(map.getPlayerWin(count) == 1){//the player is already lost, set it to game lose
                p.setStatus("gameLose");
            }
            if(map.getWinner() != -1){//there is a winner, set all players to game over
                p.setStatus("gameOver");
                room.setStatus("gameOver");
            }
            count++;
        }

    }

    public void setServerSocket(int port) throws IOException {
        this.serverSocket = new ServerSocket(port);
    }

    /*
     * check whether each player finished their turn
     * @param room is current room
     * @return true if all players are finished
     */
    public Boolean isTurnFinished(Room room){
        List<Integer> playerIds = room.getPlayerIds();
        AbstractMap map = room.getMap();
        int count = 0;

        for(int p : playerIds){
            PlayerInfo pi = getPlayerInfo(p);

            if(!pi.getNeedWait() && pi.getCurrRoomId() == room.getRoomId() && map.getPlayerWin(count) == 2){
                return false;
                //the player is in current room, it has not game over and it has not finished its move
            }
            if(pi.getCurrRoomId() != room.getRoomId() && map.getPlayerWin(count) == 2){
                return false;
                //the player is not in current room, and it has not won or lose the game
            }
            count++;

        }
        return true;
    }

    public Boolean canRegister(String account){
        for(PlayerInfo p : playerInfos){
            if(account.equals(p.getAccount())){
                return false;
            }
        }
        return true;
    }

    public Boolean canLogin(String account, String password){
        for(PlayerInfo p : playerInfos){
            if(account.equals(p.getAccount()) && password.equals(p.getPassword())){
                return true;
            }
        }
        return false;
    }

    /**
     * start an app and accept user connections
     */
    public static void main(String[] args) throws IOException {
        App app = new App();
        if(args.length == 1)
            app.setServerSocket(Integer.parseInt(args[0]));
        else
            app.setServerSocket(54321);
        app.acceptConnection();
    }
}
